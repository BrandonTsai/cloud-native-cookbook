<html>
<head>
  <style>
  table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
  }
  th, td {
    padding: 15px;
    text-align: left;
  }
  table#t01 {
    width: 100%;
    background-color: #f1f1c1;
  }
  h2 {
    margin-top: 35px;
  }
  h3, h4 {
    margin-top: 25px;
  }
  </style>
</head>
<body>
  <p>Before Kubernetes, software applications were typically run standalone in a VM and use up all the resources. Operators and developers needed to carefully choose the size of the VM for running them. But in Kubernetes, pods/containers can run on any machine. This requires sharing resources with others.
That is where the QoS (Quality of Service Classes) and Resource Quota comes in.</p>
<h2>Resource Request and Limits</h2>
<p>When you create a pod for your application, you can set requests and limits for CPU and memory for every container inside.
Properly setting these values is the only way to instruct Kubernetes on how to reserve enough resources for your applications.</p>
<p>For example,</p>
<pre class="codehilite"><code class="language-yaml">spec:
  containers:
  - image: k8s/hello-k8s
    name: hello-k8s
    resources:
      requests:
        cpu: 100m
        memory: 200Mi
      limits:
        cpu: 200m
        memory: 400Mi</code></pre>


<p><strong>Requests</strong>: The values are used for scheduling. It is the minimum amount of resources a container needs to run. The Pods will remain in "Pending" state if no node has enough resources.</p>
<p><strong>Limits</strong>: The maximum amount for this kind of resource that the node will allow the containers to use.</p>
<ul>
<li>If a container attempts to exceed the specified cpu limit, the system will throttle the container</li>
<li>If the container exceeds the specified memory limit, it will be terminated and potentially restarted dependent upon the container restart policy.</li>
</ul>
<h2>Quality of Service Classes (QoS)</h2>
<p>A node can be overcommitted when it has pod scheduled that make no request, or when the sum of limits across all pods on that node exceeds the available machine capacity.
In an overcommitted environment, the pods on the node may attempt to use more compute resources than the ones available at any given point in time.</p>
<p>When this occurs, the node must give priority to one container over another. Containers that have the lowest priority are terminated/throttle first. The entity used to make this decision is referred as the Quality of Service (QoS) Class.</p>
<table>
<thead>
<tr>
<th>Priority</th>
<th>Class Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 (highest)</td>
<td>Guaranteed</td>
<td>If limits and optionally requests are set (not equal to 0) for all resources and they are equal.</td>
</tr>
<tr>
<td>2</td>
<td>Burstable</td>
<td>If requests and optionally limits are set (not equal to 0) for all resources, and they are not equal</td>
</tr>
<tr>
<td>3 (lowest)</td>
<td>BestEffort</td>
<td>If requests and limits are not set for any of the resources</td>
</tr>
</tbody>
</table>
<p>Therefore, if the developer does not declare CPU/Memory requests and limits, the container will be terminated first. We should protect the critical pods in production projects by setting limits so they are classified as <em>Guaranteed</em>. <em>BestEffort</em> or <em>Burstable</em> pods should be used in developing projects only.</p>
<h2>Project Quota and Limit Ranges:</h2>
<p>The administrator can set the Project Quota to restrict resource consumption.
This has an additional effect; if you set a Memory request in the quota, then all pods need to set a Memory request in their definition.
The new pod will not be scheduled and will remain pending if it tries to allocate more resources than the quota restriction.</p>
<p>A limit range is a policy to constrain resources by Pod or Container in a namespace. it can:</p>
<ul>
<li>Set default request/limit for computing resources in a namespace and automatically inject them to Containers at runtime.</li>
<li>Enforce minimum and maximum resource usage per Pod or Container in a namespace.</li>
<li>Enforce minimum and maximum storage requests per PersistentVolumeClaim in a namespace.</li>
<li>Enforce a ratio between request and limit for a resource in a namespace.</li>
</ul>
<h2>What should we monitor for managing cluster resources?</h2>
<h3>Node Status</h3>
<p>Make sure all nodes are in "Ready" state</p>
<h3>Pod Status</h3>
<p>Make sure no pod is in "Pending" Status</p>
<h3>Percentage of resource (CPU/Memory) allocated from the total available resource in the cluster</h3>
<p>A good warning threshold would be (n-1)/n*100, where n is the number of nodes.</p>
<p>Over this threshold, you may not be able to reallocate your workloads in the rest of the nodes.</p>
<h3>Percentage of Resource (CPU/Memory) Usage in the node</h3>
<p>The OS Kernel invokes OOMKiller when Memory usage comes under pressure in the node.</p>
<p>CPU Pressure will restrain processes and affect their performance.</p>
<p>A warning threshold to notify the administrator that this node may have issues or be about to reach "Eviction Policies".</p>
<ul>
<li>Check the "Eviction Policies" setting. Make sure alerts have triggered before reaching the eviction-hard thresholds.</li>
</ul>
<h3>CPU and Memory Request vs Capacity in the node</h3>
<p>Add the following warning thresholds to notify the administrator that this node may not able to allocate new pods.</p>
<ul>
<li>Less than 10% CPU can be allocated to CPU Request</li>
<li>Less than 10% Memory can be allocated to Memory Request</li>
</ul>
<p>If n-1 nodes can not allocate new pods, then it is time to scale up or check whether the CPU/Memory requests are too high or not.</p>
<h3>Disk Space in the node</h3>
<p>If the node runs out of disk, it will try to free docker space with a fair chance of pod eviction</p>
<h3>Memory and CPU usage per container</h3>
<p>Because Kubernetes limits are per container, not per pod. Therefore it is not necessary to monitor resources usage per pod.</p>
<p>Ideally, containers should use a similar amount of resources than the ones requested.
If your usage is much lower than your request this will waste valuable resources and potentially will be too hard to allocate new pods.
On the opposite case, usage is higher than resources, you might face performance issues.</p>
<h2>Conclusion</h2>
<p>It is important to make sure requests and limits are declared and tested before deploying to production. Cluster admins can set up a namespace quota to enforce all of the workloads in the namespace to have a request and limit in every container. A good configuration of requests and limits will make your applications much more stable.</p>
<p>Appropriate monitoring and alerts will help the cluster admin to reduce the waste of the cluster resources and avoid performance issue. Ask us today if you need help to monitor your Kubernetes system! :) </p>
<h2>Reference:</h2>
<ul>
<li>https://kubernetes.io/docs/concepts/policy/resource-quotas/</li>
<li>https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/</li>
<li>https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/</li>
</ul>
</body>
</html>